using Microsoft.CSharp;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace ECSlike
{
    public class ECSlikeGenerator
    {
        public static readonly string ComponentSuffix = "Component";
        public static readonly string ComponentConfigSuffix = "ConfigScript";
        public static readonly string ComponentExtensionsSuffix = "Extensions";
        public static readonly string ComponentConfigTemplate = "" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "//" +
            "\n" +
            "// Generated By ECSlikeGenerator" +
            "\n" +
            "//" +
            "\n" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "\n" +
            "using UnityEngine;" +
            "\n" +
            "\n" +
            "namespace {namespace}" +
            "\n" +
            "{" +
            "\n" +
            "    [DisallowMultipleComponent]" +
            "\n" +
            "    public class {classname} : MonoBehaviour, ECSlike.IComponentConfig" +
            "\n" +
            "    {" +
            "\n" +
            "{fields}" +
            "\n" +
            "    }" +
            "\n" +
            "}" +
            "";
        public static readonly string ComponentExtensionsTemplate = "" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "//" +
            "\n" +
            "// Generated By ECSlikeGenerator" +
            "\n" +
            "//" +
            "\n" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "\n" +
            "namespace {namespace}" +
            "\n" +
            "{" +
            "\n" +
            "    public static class {classname}" +
            "\n" +
            "    {" +
            "\n" +
            "{methods}" +
            "\n" +
            "    }" +
            "\n" +
            "}" +
            "";
        public static readonly string ComponentSetupMethodTemplate = "" +
            "        public static ECSlike.IComponent Create(ECSlike.IComponentConfig config)" +
            "\n" +
            "        {" +
            "\n" +
            "            {component} component = new {component}();" +
            "\n" +
            "            component.setup(config as {config});" +
            "\n" +
            "            return component;" +
            "\n" +
            "        }" +
            "\n" +
            "\n" +
            "        public static void setup(this {component} self, {config} config)" +
            "\n" +
            "        {" +
            "\n" +
            "{assigns}" +
            "\n" +
            "        }" +
            "";
        public static readonly string WorldInitializerTemplate = "" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "//" +
            "\n" +
            "// Generated By ECSlikeGenerator" +
            "\n" +
            "//" +
            "\n" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "\n" +
            "namespace {namespace}" +
            "\n" +
            "{" +
            "\n" +
            "    public class {classname}" +
            "\n" +
            "    {" +
            "\n" +
            "        public ECSlike.ComponentRegisterData[] getRegisterDatas()" +
            "\n" +
            "        {" +
            "\n" +
            "            ECSlike.ComponentRegisterData[] datas = new ECSlike.ComponentRegisterData[]" +
            "\n" +
            "            {" +
            "\n" +
            "{components}" +
            "\n" +
            "            };" +
            "\n" +
            "            return datas;" +
            "\n" +
            "        }" +
            "\n" +
            "    }" +
            "\n" +
            "}" +
            "";
        public static readonly string ComponentWithConfigRegisterDataTemplate = "" +
            "                new ECSlike.ComponentRegisterData(typeof({component}), typeof({config}), {extensions}.Create)," +
            "";
        public static readonly string ComponentNoConfigRegisterDataTemplate = "" +
            "                new ECSlike.ComponentRegisterData(typeof({component}), null, null)," +
            "";
        public static readonly string ComponentGizmosDrawerTemplate = "" +
            "        private void OnDrawGizmos()" +
            "\n" +
            "        {" +
            "\n" +
            "{gizmos}" +
            "\n" +
            "        }" +
            "";

        [MenuItem("ECSlike/Generate Codes", false, 1000)]
        public static void GenerateCodes()
        {
            ECSlikePreferences preferences = ECSlikePreferences.Load();
            if (preferences.worlds.Count <= 0)
            {
                if (EditorUtility.DisplayDialog("Generate Failed", "No World", "Go to setup", "Cancel"))
                {
                    ECSlikePreferencesEditWindow.Open();
                }
                return;
            }
            int count = preferences.worlds.Count;
            for (int i = 0; i < count; i++)
            {
                if (string.IsNullOrEmpty(preferences.worlds[i].worldName))
                {
                    if (EditorUtility.DisplayDialog("Generate Failed", "Missing worldName", "Go to setup", "Cancel"))
                    {
                        ECSlikePreferencesEditWindow.Open();
                    }
                    return;
                }
                if (string.IsNullOrEmpty(preferences.worlds[i].input))
                {
                    if (EditorUtility.DisplayDialog("Generate Failed", "Missing input", "Go to setup", "Cancel"))
                    {
                        ECSlikePreferencesEditWindow.Open();
                    }
                    return;
                }
                if (string.IsNullOrEmpty(preferences.worlds[i].output))
                {
                    if (EditorUtility.DisplayDialog("Generate Failed", "Missing output", "Go to setup", "Cancel"))
                    {
                        ECSlikePreferencesEditWindow.Open();
                    }
                    return;
                }
            }
            EditorUtility.DisplayProgressBar("Generate Codes", "", 0f);
            count = preferences.worlds.Count;
            for (int i = 0; i < count; i++)
            {
                GenerateCodes(preferences.worlds[i]);
            }
            EditorUtility.ClearProgressBar();
        }

        public static void GenerateCodes(ECSlikeWorldInfo worldInfo)
        {
            GenerateCodes(worldInfo, ReadCodeTypes(worldInfo));
        }

        protected static bool IsWantedAssembly(string location)
        {
            location = location.Replace("\\", "/");
            if (location.Contains("Assembly-CSharp")) return false;
            if (location.EndsWith("mscorlib.dll")) return false;
            return true;
        }

        protected static IList<System.Type> ReadCodeTypes(ECSlikeWorldInfo worldInfo)
        {
            EditorUtility.DisplayProgressBar("Generate Codes", string.Format("read from {0}", worldInfo.input), 0f);
            if (string.IsNullOrEmpty(worldInfo.input)) return null;
            string[] inputFiles = System.IO.Directory.GetFiles(worldInfo.input, "*.cs", System.IO.SearchOption.AllDirectories);
            if (inputFiles == null || inputFiles.Length <= 0) return null;
            List<string> files = new List<string>(inputFiles);
            string[] outputFiles = System.IO.Directory.GetFiles(worldInfo.output, "*.cs", System.IO.SearchOption.AllDirectories);
            if (outputFiles != null && outputFiles.Length > 0)
            {
                files.AddRange(outputFiles);
            }
            CSharpCodeProvider codeProvider = new CSharpCodeProvider();
            CompilerParameters compilerParameters = new CompilerParameters();
            Assembly[] assemblies = System.AppDomain.CurrentDomain.GetAssemblies();
            string location;
            int count = assemblies.Length;
            for (int i = 0; i < count; i++)
            {
                try
                {
                    location = assemblies[i].Location;
                    if (!IsWantedAssembly(location)) continue;
                    compilerParameters.ReferencedAssemblies.Add(location);
                }
                catch
                {
                    continue;
                }
            }
            compilerParameters.GenerateExecutable = false;
            compilerParameters.GenerateInMemory = true;
            compilerParameters.CompilerOptions += "/d:UNITY_EDITOR";
            CompilerResults results = codeProvider.CompileAssemblyFromFile(compilerParameters, files.ToArray());
            if (results.Errors.HasErrors)
            {
                int errorCount = 0;
                count = results.Errors.Count;
                for (int i = 0; i < count; i++)
                {
                    if (results.Errors[i].IsWarning)
                    {
                        Debug.LogWarningFormat("Compile code warning in [{0}]({1}, {2}): {3}", results.Errors[i].FileName, results.Errors[i].Line, results.Errors[i].Column, results.Errors[i].ErrorText);
                    }
                    else
                    {
                        errorCount++;
                        Debug.LogErrorFormat("Compile code error in [{0}]({1}, {2}): {3}", results.Errors[i].FileName, results.Errors[i].Line, results.Errors[i].Column, results.Errors[i].ErrorText);
                    }
                }
                if (errorCount > 0)
                {
                    return null;
                }
            }
            Assembly codeAssembly = results.CompiledAssembly;
            return codeAssembly.GetTypes();
        }

        protected static void GenerateCodes(ECSlikeWorldInfo worldInfo, IList<System.Type> codeTypes)
        {
            EditorUtility.DisplayProgressBar("Generate Codes", string.Format("{0} generating...", worldInfo.worldName), 0f);
            if (codeTypes == null || codeTypes.Count <= 0)
            {
                if (EditorUtility.DisplayDialog("Generate Failed", "Nothing to generate", "Ok"))
                {
                    return;
                }
            }
            string generateRoot = worldInfo.output;
            Dictionary<string, string> existFiles = new Dictionary<string, string>();
            if (!System.IO.Directory.Exists(generateRoot))
            {
                System.IO.Directory.CreateDirectory(generateRoot);
            }
            else
            {
                string[] files = System.IO.Directory.GetFiles(generateRoot, "*.cs", System.IO.SearchOption.AllDirectories);
                if (files != null && files.Length > 0)
                {
                    int fileCount = files.Length;
                    for (int i = 0; i < fileCount; i++)
                    {
                        existFiles.Add(System.IO.Path.GetFileNameWithoutExtension(files[i]), files[i]);
                    }
                }
            }
            string worldName = worldInfo.worldName;
            int success = 0;
            int total = 0;
            if (codeTypes.Count > 0)
            {
                System.Type componentBaseType = typeof(IComponent);
                List<KeyValuePair<System.Type, bool>> generatedTypes = new List<KeyValuePair<System.Type, bool>>();
                bool hasConfigScript;
                int count = codeTypes.Count;
                for (int i = 0; i < count; i++)
                {
                    if (!componentBaseType.IsAssignableFrom(codeTypes[i]))
                    {
                        continue;
                    }
                    if (codeTypes[i].GetCustomAttribute<System.ObsoleteAttribute>() != null)
                    {
                        continue;
                    }
                    total++;
                    hasConfigScript = GenerateComponent(codeTypes[i], generateRoot, existFiles);
                    generatedTypes.Add(new KeyValuePair<System.Type, bool>(codeTypes[i], hasConfigScript));
                    success++;
                }
                total++;
                if (GenerateWorld(generatedTypes, worldName, generateRoot, existFiles))
                {
                    success++;
                }
            }
            if (existFiles.Count > 0)
            {
                foreach (KeyValuePair<string, string> kv in existFiles)
                {
                    System.IO.File.Delete(kv.Value);
                    System.IO.File.Delete(string.Format("{0}.meta", kv.Value));
                }
                existFiles.Clear();
            }
            AssetDatabase.Refresh();
            Debug.LogFormat("Generate {0} Codes Complete: {1} / {2}", worldInfo.worldName, success, total);
        }

        public static bool GenerateComponent(System.Type type, string generateRoot, Dictionary<string, string> existFiles)
        {
            if (type.IsAbstract) return false;
            object inst = type.Assembly.CreateInstance(type.FullName);
            string componentNamespace = type.Namespace;
            string componentClassName = type.Name;
            string componentName = componentClassName;
            if (componentName.EndsWith(ComponentSuffix))
            {
                componentName = componentName.Substring(0, componentName.Length - ComponentSuffix.Length);
            }
            string componentConfigClassName = string.Format("{0}{1}", componentName, ComponentConfigSuffix);
            string componentExtensionsClassName = string.Format("{0}{1}", componentClassName, ComponentExtensionsSuffix);
            string generatedFolder = System.IO.Path.Combine(generateRoot, "Component");
            if (!System.IO.Directory.Exists(generatedFolder))
            {
                System.IO.Directory.CreateDirectory(generatedFolder);
            }
            string generatedFilePath = System.IO.Path.Combine(generatedFolder, string.Format("{0}.cs", componentConfigClassName));
            List<FieldInfo> configFields = new List<FieldInfo>();
            List<ConfigFieldAttribute> configFieldAttributes = new List<ConfigFieldAttribute>();
            int count;
            FieldInfo[] fieldInfos = type.GetFields(BindingFlags.Public | BindingFlags.Instance);
            if (fieldInfos != null && fieldInfos.Length > 0)
            {
                ConfigFieldAttribute configFieldAttribute;
                count = fieldInfos.Length;
                for (int i = 0; i < count; i++)
                {
                    configFieldAttribute = fieldInfos[i].GetCustomAttribute<ConfigFieldAttribute>();
                    if (configFieldAttribute != null)
                    {
                        configFields.Add(fieldInfos[i]);
                        configFieldAttributes.Add(configFieldAttribute);
                    }
                }
            }
            if (configFields.Count <= 0)
            {
                if (type.GetCustomAttribute<ConfigClassAttribute>() == null)
                {
                    if (System.IO.File.Exists(generatedFilePath))
                    {
                        System.IO.File.Delete(generatedFilePath);
                    }
                    return false;
                }
            }
            string fieldsDefineCodes = string.Empty;
            string fieldsAssignCodes = string.Empty;
            string fieldsGizmosCodes = string.Empty;
            bool isMonoProperty;
            count = configFields.Count;
            for (int i = 0; i < count; i++)
            {
                if (!string.IsNullOrEmpty(fieldsDefineCodes))
                {
                    fieldsDefineCodes = string.Format("{0}\n", fieldsDefineCodes);
                }
                if (!string.IsNullOrEmpty(fieldsAssignCodes))
                {
                    fieldsAssignCodes = string.Format("{0}\n", fieldsAssignCodes);
                }
                if (!string.IsNullOrEmpty(fieldsGizmosCodes))
                {
                    fieldsGizmosCodes = string.Format("{0}\n", fieldsGizmosCodes);
                }
                isMonoProperty = IsMonoProperty(configFields[i]);
                if (isMonoProperty)
                {
                    fieldsAssignCodes = string.Format("{0}            self.{1} = config.{1};", fieldsAssignCodes, configFields[i].Name);
                }
                else
                {
                    if (string.IsNullOrEmpty(configFieldAttributes[i].init))
                    {
                        fieldsDefineCodes = string.Format("{0}        public {1} {2} = {3};", fieldsDefineCodes, GetTypeName(configFields[i].FieldType, componentNamespace), configFields[i].Name, GetFieldDefaultValue(configFields[i], configFields[i].FieldType, componentNamespace, inst));
                        fieldsAssignCodes = string.Format("{0}            self.{1} = config.{1};", fieldsAssignCodes, configFields[i].Name);
                    }
                    else
                    {
                        fieldsAssignCodes = string.Format("{0}            self.{1} = config.{2};", fieldsAssignCodes, configFields[i].Name, configFieldAttributes[i].init);
                    }
                    if (!string.IsNullOrEmpty(configFieldAttributes[i].gizmosDrawer))
                    {
                        if (configFieldAttributes[i].gizmosDrawer.Contains("."))
                        {
                            fieldsGizmosCodes = string.Format("{0}            {1}.Invoke(transform, {2});", fieldsGizmosCodes, configFieldAttributes[i].gizmosDrawer, configFields[i].Name);
                        }
                        else
                        {
                            fieldsGizmosCodes = string.Format("{0}            {1}.{2}(transform, {3});", fieldsGizmosCodes, componentClassName, configFieldAttributes[i].gizmosDrawer, configFields[i].Name);
                        }
                    }
                }
            }
            if (typeof(IComponentInitializer).IsAssignableFrom(type))
            {
                if (!string.IsNullOrEmpty(fieldsAssignCodes))
                {
                    fieldsAssignCodes = string.Format("{0}\n", fieldsAssignCodes);
                }
                fieldsAssignCodes = string.Format("{0}            self.initComponent();", fieldsAssignCodes);
            }
            if (!string.IsNullOrEmpty(fieldsGizmosCodes))
            {
                fieldsDefineCodes = string.Format("{0}\n", fieldsDefineCodes);
                string gizmosCode = ComponentGizmosDrawerTemplate;
                gizmosCode = gizmosCode.Replace("{gizmos}", fieldsGizmosCodes);
                fieldsDefineCodes = string.Format("{0}\n", fieldsDefineCodes);
                fieldsDefineCodes = string.Format("{0}{1}", fieldsDefineCodes, gizmosCode);
            }
            string configCode = ComponentConfigTemplate;
            configCode = configCode.Replace("{namespace}", componentNamespace);
            configCode = configCode.Replace("{classname}", componentConfigClassName);
            configCode = configCode.Replace("{fields}", fieldsDefineCodes);
            System.IO.File.WriteAllText(generatedFilePath, configCode);
            existFiles.Remove(componentConfigClassName);
            string setupMethodCode = ComponentSetupMethodTemplate;
            setupMethodCode = setupMethodCode.Replace("{component}", componentClassName);
            setupMethodCode = setupMethodCode.Replace("{config}", componentConfigClassName);
            setupMethodCode = setupMethodCode.Replace("{assigns}", fieldsAssignCodes);
            string extensionCode = ComponentExtensionsTemplate;
            extensionCode = extensionCode.Replace("{namespace}", componentNamespace);
            extensionCode = extensionCode.Replace("{classname}", componentExtensionsClassName);
            extensionCode = extensionCode.Replace("{methods}", setupMethodCode);
            generatedFilePath = System.IO.Path.Combine(generatedFolder, string.Format("{0}.cs", componentExtensionsClassName));
            System.IO.File.WriteAllText(generatedFilePath, extensionCode);
            existFiles.Remove(componentExtensionsClassName);
            return true;
        }

        protected static bool GenerateWorld(List<KeyValuePair<System.Type, bool>> componentTypes, string worldName, string generateRoot, Dictionary<string, string> existFiles)
        {
            string generatedFolder = generateRoot;
            string worldInitializerClassName = string.Format("{0}Initializer", worldName);
            string generatedFilePath = System.IO.Path.Combine(generatedFolder, string.Format("{0}.cs", worldInitializerClassName));
            if (componentTypes.Count <= 0)
            {
                if (System.IO.File.Exists(generatedFilePath))
                {
                    System.IO.File.Delete(generatedFilePath);
                }
                return false;
            }
            string componentsCode = string.Empty;
            string componentRegisterCode;
            string componentClassName;
            string componentName;
            int count = componentTypes.Count;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {
                    componentsCode = string.Format("{0}\n", componentsCode);
                }
                componentClassName = componentTypes[i].Key.Name;
                componentName = componentClassName;
                if (componentName.EndsWith(ComponentSuffix))
                {
                    componentName = componentName.Substring(0, componentName.Length - ComponentSuffix.Length);
                }
                if (componentTypes[i].Value)
                {
                    componentRegisterCode = ComponentWithConfigRegisterDataTemplate;
                    componentRegisterCode = componentRegisterCode.Replace("{config}", string.Format("{0}{1}", componentName, ComponentConfigSuffix));
                    componentRegisterCode = componentRegisterCode.Replace("{extensions}", string.Format("{0}{1}", componentClassName, ComponentExtensionsSuffix));
                }
                else
                {
                    componentRegisterCode = ComponentNoConfigRegisterDataTemplate;
                }
                componentRegisterCode = componentRegisterCode.Replace("{component}", componentClassName);
                componentsCode = string.Format("{0}{1}", componentsCode, componentRegisterCode);
            }
            string worldNamespace = componentTypes[0].Key.Namespace;
            string worldInitializerCode = WorldInitializerTemplate;
            worldInitializerCode = worldInitializerCode.Replace("{namespace}", worldNamespace);
            worldInitializerCode = worldInitializerCode.Replace("{classname}", worldInitializerClassName);
            worldInitializerCode = worldInitializerCode.Replace("{components}", componentsCode);
            System.IO.File.WriteAllText(generatedFilePath, worldInitializerCode);
            existFiles.Remove(worldInitializerClassName);
            return true;
        }

        protected static bool IsMonoProperty(FieldInfo field)
        {
            System.Type monoType = typeof(MonoBehaviour);
            MemberInfo[] memberInfos = monoType.GetMember(field.Name);
            if (memberInfos == null || memberInfos.Length <= 0) return false;
            PropertyInfo propertyInfo;
            FieldInfo fieldInfo;
            int count = memberInfos.Length;
            for(int i = 0; i < count; i++)
            {
                if (memberInfos[i].MemberType == MemberTypes.Property)
                {
                    propertyInfo = memberInfos[i] as PropertyInfo;
                    if (propertyInfo.PropertyType.Equals(field.FieldType))
                    {
                        return true;
                    }
                }
                else if (memberInfos[i].MemberType == MemberTypes.Field)
                {
                    fieldInfo = memberInfos[i] as FieldInfo;
                    if (fieldInfo.IsPrivate) continue;
                    if (fieldInfo.FieldType.Equals(field.FieldType))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        protected static string GetTypeName(System.Type type, string nameSpace)
        {
            if (type.IsGenericType)
            {
                string typeName = type.GetGenericTypeDefinition().FullName;
                typeName = typeName.Substring(0, typeName.Length - 2);
                string paramName = string.Empty;
                System.Type[] paramTypes = type.GenericTypeArguments;
                int count = paramTypes.Length;
                for (int i = 0; i < count; i++)
                {
                    if (i > 0)
                    {
                        paramName = string.Format("{0}, ", paramName);
                    }
                    paramName = string.Format("{0}{1}", paramName, GetTypeName(paramTypes[i], nameSpace));
                }
                return string.Format("{0}<{1}>", typeName, paramName);
            }
            if (type.Equals(typeof(bool))) return "bool";
            if (type.Equals(typeof(short))) return "short";
            if (type.Equals(typeof(int))) return "int";
            if (type.Equals(typeof(long))) return "long";
            if (type.Equals(typeof(ushort))) return "ushort";
            if (type.Equals(typeof(uint))) return "uint";
            if (type.Equals(typeof(ulong))) return "ulong";
            if (type.Equals(typeof(float))) return "float";
            if (type.Equals(typeof(double))) return "double";
            if (type.Equals(typeof(string))) return "string";
            if (type.Namespace.Equals(nameSpace))
            {
                return type.Name;
            }
            return type.FullName;
        }

        protected static string GetFieldDefaultValue(FieldInfo fieldInfo, System.Type fieldType, string nameSpace, object inst)
        {
            if (fieldType.IsGenericType)
            {
                return GetTypeDefaultValue(fieldType, nameSpace);
            }
            object value = fieldInfo.GetValue(inst);
            if (value == null)
            {
                return GetTypeDefaultValue(fieldType, nameSpace);
            }
            if (value is LayerMask)
            {
                return (((LayerMask)value).value).ToString();
            }
            if (fieldType.IsEnum)
            {
                return string.Format("{0}.{1}", fieldType.Name, value.ToString());
            }
            if (typeof(string).IsAssignableFrom(fieldType))
            {
                if (string.IsNullOrEmpty((string)value))
                {
                    return "string.Empty";
                }
                return string.Format("\"{0}\"", (string)value);
            }
            if (fieldType.IsSerializable)
            {
                if (!fieldType.IsValueType)
                {
                    return string.Format("new {0}()", value.ToString());
                }
            }
            if (value is bool)
            {
                return value.ToString().ToLower();
            }
            if (value is float)
            {
                return string.Format("{0}f", value);
            }
            return value.ToString();
        }

        protected static string GetTypeDefaultValue(System.Type type, string nameSpace)
        {
            if (type.IsGenericType)
            {
                string typeName = type.GetGenericTypeDefinition().FullName;
                typeName = typeName.Substring(0, typeName.Length - 2);
                string paramName = string.Empty;
                System.Type[] paramTypes = type.GenericTypeArguments;
                int count = paramTypes.Length;
                for (int i = 0; i < count; i++)
                {
                    if (i > 0)
                    {
                        paramName = string.Format("{0}, ", paramName);
                    }
                    paramName = string.Format("{0}{1}", paramName, GetTypeName(paramTypes[i], nameSpace));
                }
                return string.Format("new {0}<{1}>()", typeName, paramName);
            }
            if (type.Equals(typeof(bool))) return "false";
            if (type.Equals(typeof(short))) return "0";
            if (type.Equals(typeof(int))) return "0";
            if (type.Equals(typeof(long))) return "0";
            if (type.Equals(typeof(ushort))) return "0";
            if (type.Equals(typeof(uint))) return "0";
            if (type.Equals(typeof(ulong))) return "0";
            if (type.Equals(typeof(float))) return "0f";
            if (type.Equals(typeof(double))) return "0";
            if (type.Equals(typeof(string))) return "string.Empty";
            if (type.IsEnum) return string.Format("{0}.{1}", type.Name, type.GetEnumValues().GetValue(0).ToString());
            if (type.IsValueType) return string.Empty;
            return "null";
        }
    }
}
