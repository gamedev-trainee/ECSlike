using Microsoft.CSharp;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace ECSlike
{
    public class ECSlikeGenerator
    {
        public static readonly string ComponentSuffix = "Component";
        public static readonly string ComponentConfigSuffix = "ConfigScript";
        public static readonly string ComponentExtensionsSuffix = "Extensions";
        public static readonly string ComponentConfigTemplate = "" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "//" +
            "\n" +
            "// Generated By ECSlikeGenerator" +
            "\n" +
            "//" +
            "\n" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "\n" +
            "using UnityEngine;" +
            "\n" +
            "\n" +
            "namespace {namespace}" +
            "\n" +
            "{" +
            "\n" +
            "    public class {classname} : MonoBehaviour, ECSlike.IComponentConfig" +
            "\n" +
            "    {" +
            "\n" +
            "{fields}" +
            "\n" +
            "    }" +
            "\n" +
            "}" +
            "";
        public static readonly string ComponentExtensionsTemplate = "" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "//" +
            "\n" +
            "// Generated By ECSlikeGenerator" +
            "\n" +
            "//" +
            "\n" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "\n" +
            "namespace {namespace}" +
            "\n" +
            "{" +
            "\n" +
            "    public static class {classname}" +
            "\n" +
            "    {" +
            "\n" +
            "{methods}" +
            "\n" +
            "    }" +
            "\n" +
            "}" +
            "";
        public static readonly string ComponentSetupMethodTemplate = "" +
            "        public static ECSlike.IComponent Create(ECSlike.IComponentConfig config)" +
            "\n" +
            "        {" +
            "\n" +
            "            {component} component = new {component}();" +
            "\n" +
            "            component.setup(config as {config});" +
            "\n" +
            "            return component;" +
            "\n" +
            "        }" +
            "\n" +
            "\n" +
            "        public static void setup(this {component} self, {config} config)" +
            "\n" +
            "        {" +
            "\n" +
            "{assigns}" +
            "\n" +
            "        }" +
            "";
        public static readonly string WorldTemplate = "" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "//" +
            "\n" +
            "// Generated By ECSlikeGenerator" +
            "\n" +
            "//" +
            "\n" +
            "/////////////////////////////////////////////////" +
            "\n" +
            "\n" +
            "namespace {namespace}" +
            "\n" +
            "{" +
            "\n" +
            "    public class {classname} : ECSlike.World" +
            "\n" +
            "    {" +
            "\n" +
            "        public static {classname} ms_instance = null;" +
            "\n" +
            "\n" +
            "        public static {classname} Instance" +
            "\n" +
            "        {" +
            "\n" +
            "            get" +
            "\n" +
            "            {" +
            "\n" +
            "                if (ms_instance == null)" +
            "\n" +
            "                {" +
            "\n" +
            "                    ms_instance = new {classname}();" +
            "\n" +
            "                }" +
            "\n" +
            "                return ms_instance;" +
            "\n" +
            "            }" +
            "\n" +
            "        }" +
            "\n" +
            "\n" +
            "        public {classname}() : base(new ECSlike.ComponentRegisterData[]" +
            "\n" +
            "        {" +
            "\n" +
            "{components}" +
            "\n" +
            "        })" +
            "\n" +
            "        {" +
            "\n" +
            "\n" +
            "        }" +
            "\n" +
            "    }" +
            "\n" +
            "}" +
            "";
        public static readonly string ComponentRegisterDataTemplate = "" +
            "            new ECSlike.ComponentRegisterData(typeof({component}), typeof({config}), {extensions}.Create)," +
            "";
        public static readonly string DefaultWorldName = "ECSWorld";

        [MenuItem("ECSlike/Generate Codes", false, 1000)]
        public static void GenerateCodes()
        {
            ECSlikePreferences preferences = ECSlikePreferences.Load();
            if (preferences.worlds.Count <= 0)
            {
                if (EditorUtility.DisplayDialog("Generate Failed", "No World", "Go to setup", "Cancel"))
                {
                    ECSlikePreferencesEditWindow.Open();
                }
                return;
            }
            int count = preferences.worlds.Count;
            for (int i = 0; i < count; i++)
            {
                if (string.IsNullOrEmpty(preferences.worlds[i].worldName))
                {
                    if (EditorUtility.DisplayDialog("Generate Failed", "Missing worldName", "Go to setup", "Cancel"))
                    {
                        ECSlikePreferencesEditWindow.Open();
                    }
                    return;
                }
                if (string.IsNullOrEmpty(preferences.worlds[i].input))
                {
                    if (EditorUtility.DisplayDialog("Generate Failed", "Missing input", "Go to setup", "Cancel"))
                    {
                        ECSlikePreferencesEditWindow.Open();
                    }
                    return;
                }
                if (string.IsNullOrEmpty(preferences.worlds[i].output))
                {
                    if (EditorUtility.DisplayDialog("Generate Failed", "Missing output", "Go to setup", "Cancel"))
                    {
                        ECSlikePreferencesEditWindow.Open();
                    }
                    return;
                }
            }
            EditorUtility.DisplayProgressBar("Generate Codes", "", 0f);
            count = preferences.worlds.Count;
            for (int i = 0; i < count; i++)
            {
                GenerateCodes(preferences.worlds[i]);
            }
            EditorUtility.ClearProgressBar();
        }

        public static void GenerateCodes(ECSlikeWorldInfo worldInfo)
        {
            GenerateCodes(worldInfo, ReadCodeTypes(worldInfo));
        }

        protected static bool IsWantedAssembly(string location)
        {
            location = location.Replace("\\", "/");
            if (location.EndsWith("mscorlib.dll")) return false;
            return true;
        }

        protected static IList<System.Type> ReadCodeTypes(ECSlikeWorldInfo worldInfo)
        {
            EditorUtility.DisplayProgressBar("Generate Codes", string.Format("read from {0}", worldInfo.input), 0f);
            if (string.IsNullOrEmpty(worldInfo.input)) return null;
            string[] files = System.IO.Directory.GetFiles(worldInfo.input, "*.cs", System.IO.SearchOption.AllDirectories);
            if (files == null || files.Length <= 0) return null;
            CSharpCodeProvider codeProvider = new CSharpCodeProvider();
            CompilerParameters compilerParameters = new CompilerParameters();
            Assembly[] assemblies = System.AppDomain.CurrentDomain.GetAssemblies();
            string location;
            int count = assemblies.Length;
            for (int i = 0; i < count; i++)
            {
                try
                {
                    location = assemblies[i].Location;
                    if (!IsWantedAssembly(location)) continue;
                    compilerParameters.ReferencedAssemblies.Add(location);
                }
                catch
                {
                    continue;
                }
            }
            compilerParameters.GenerateExecutable = false;
            compilerParameters.GenerateInMemory = true;
            CompilerResults results = codeProvider.CompileAssemblyFromFile(compilerParameters, files);
            if (results.Errors.HasErrors)
            {
                count = results.Errors.Count;
                for (int i = 0; i < count; i++)
                {
                    Debug.LogErrorFormat("Compile code error: {0}", results.Errors[i].ErrorText);
                }
                return null;
            }
            Assembly codeAssembly = results.CompiledAssembly;
            return codeAssembly.GetTypes();
        }

        protected static void GenerateCodes(ECSlikeWorldInfo worldInfo, IList<System.Type> codeTypes)
        {
            EditorUtility.DisplayProgressBar("Generate Codes", string.Format("{0} generating...", worldInfo.worldName), 0f);
            if (codeTypes == null || codeTypes.Count <= 0)
            {
                if (EditorUtility.DisplayDialog("Generate Failed", "Nothing to generate", "Ok"))
                {
                    return;
                }
            }
            string generateRoot = worldInfo.output;
            string worldName = worldInfo.worldName;
            int success = 0;
            int total = 0;
            if (codeTypes.Count > 0)
            {
                System.Type componentBaseType = typeof(IComponent);
                List<System.Type> generatedTypes = new List<System.Type>();
                int count = codeTypes.Count;
                for (int i = 0; i < count; i++)
                {
                    if (!componentBaseType.IsAssignableFrom(codeTypes[i]))
                    {
                        continue;
                    }
                    total++;
                    if (GenerateComponent(codeTypes[i], generateRoot))
                    {
                        generatedTypes.Add(codeTypes[i]);
                        success++;
                    }
                }
                total++;
                if (GenerateWorld(generatedTypes, worldName, generateRoot))
                {
                    success++;
                }
            }
            AssetDatabase.Refresh();
            Debug.LogFormat("Generate {0} Codes Complete: {1} / {2}", worldInfo.worldName, success, total);
        }

        public static bool GenerateComponent(System.Type type, string generateRoot)
        {
            string componentNamespace = type.Namespace;
            string componentClassName = type.Name;
            string componentName = componentClassName;
            if (componentName.EndsWith(ComponentSuffix))
            {
                componentName = componentName.Substring(0, componentName.Length - ComponentSuffix.Length);
            }
            string componentConfigClassName = string.Format("{0}{1}", componentName, ComponentConfigSuffix);
            string componentExtensionsClassName = string.Format("{0}{1}", componentClassName, ComponentExtensionsSuffix);
            string generatedFolder = System.IO.Path.Combine(generateRoot, "Component");
            if (!System.IO.Directory.Exists(generatedFolder))
            {
                System.IO.Directory.CreateDirectory(generatedFolder);
            }
            string generatedFilePath = System.IO.Path.Combine(generatedFolder, string.Format("{0}.cs", componentConfigClassName));
            List<FieldInfo> configFields = new List<FieldInfo>();
            int count;
            FieldInfo[] fieldInfos = type.GetFields(BindingFlags.Public | BindingFlags.Instance);
            if (fieldInfos != null && fieldInfos.Length > 0)
            {
                ConfigFieldAttribute configFieldAttribute;
                count = fieldInfos.Length;
                for (int i = 0; i < count; i++)
                {
                    configFieldAttribute = fieldInfos[i].GetCustomAttribute<ConfigFieldAttribute>();
                    if (configFieldAttribute == null) continue;
                    configFields.Add(fieldInfos[i]);
                }
            }
            if (configFields.Count <= 0)
            {
                if (System.IO.File.Exists(generatedFilePath))
                {
                    System.IO.File.Delete(generatedFilePath);
                }
                return false;
            }
            string fieldsDefineCodes = string.Empty;
            string fieldsAssignCodes = string.Empty;
            bool isMonoProperty;
            count = configFields.Count;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {
                    fieldsDefineCodes = string.Format("{0}\n", fieldsDefineCodes);
                    fieldsAssignCodes = string.Format("{0}\n", fieldsAssignCodes);
                }
                isMonoProperty = IsMonoProperty(configFields[i]);
                if (!isMonoProperty)
                {
                    fieldsDefineCodes = string.Format("{0}        public {1} {2} = {3};", fieldsDefineCodes, GetTypeName(configFields[i].FieldType), configFields[i].Name, GetTypeDefaultValue(configFields[i].FieldType));
                }
                fieldsAssignCodes = string.Format("{0}            self.{1} = config.{1};", fieldsAssignCodes, configFields[i].Name);
            }
            string configCode = ComponentConfigTemplate;
            configCode = configCode.Replace("{namespace}", componentNamespace);
            configCode = configCode.Replace("{classname}", componentConfigClassName);
            configCode = configCode.Replace("{fields}", fieldsDefineCodes);
            System.IO.File.WriteAllText(generatedFilePath, configCode);
            string setupMethodCode = ComponentSetupMethodTemplate;
            setupMethodCode = setupMethodCode.Replace("{component}", componentClassName);
            setupMethodCode = setupMethodCode.Replace("{config}", componentConfigClassName);
            setupMethodCode = setupMethodCode.Replace("{assigns}", fieldsAssignCodes);
            string extensionCode = ComponentExtensionsTemplate;
            extensionCode = extensionCode.Replace("{namespace}", componentNamespace);
            extensionCode = extensionCode.Replace("{classname}", componentExtensionsClassName);
            extensionCode = extensionCode.Replace("{methods}", setupMethodCode);
            generatedFilePath = System.IO.Path.Combine(generatedFolder, string.Format("{0}.cs", componentExtensionsClassName));
            System.IO.File.WriteAllText(generatedFilePath, extensionCode);
            return true;
        }

        protected static bool GenerateWorld(List<System.Type> componentTypes, string worldName, string generateRoot)
        {
            string generatedFolder = generateRoot;
            if (!System.IO.Directory.Exists(generatedFolder))
            {
                System.IO.Directory.CreateDirectory(generatedFolder);
            }
            string generatedFilePath = System.IO.Path.Combine(generatedFolder, string.Format("{0}.cs", worldName));
            if (componentTypes.Count <= 0)
            {
                if (System.IO.File.Exists(generatedFilePath))
                {
                    System.IO.File.Delete(generatedFilePath);
                }
                return false;
            }
            string componentsCode = string.Empty;
            string componentRegisterCode;
            string componentClassName;
            string componentName;
            int count = componentTypes.Count;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {
                    componentsCode = string.Format("{0}\n", componentsCode);
                }
                componentClassName = componentTypes[i].Name;
                componentName = componentClassName;
                if (componentName.EndsWith(ComponentSuffix))
                {
                    componentName = componentName.Substring(0, componentName.Length - ComponentSuffix.Length);
                }
                componentRegisterCode = ComponentRegisterDataTemplate;
                componentRegisterCode = componentRegisterCode.Replace("{component}", componentClassName);
                componentRegisterCode = componentRegisterCode.Replace("{config}", string.Format("{0}{1}", componentName, ComponentConfigSuffix));
                componentRegisterCode = componentRegisterCode.Replace("{extensions}", string.Format("{0}{1}", componentClassName, ComponentExtensionsSuffix));
                componentsCode = string.Format("{0}{1}", componentsCode, componentRegisterCode);
            }
            string worldCode = WorldTemplate;
            string worldNamespace = componentTypes[0].Namespace;
            worldCode = worldCode.Replace("{namespace}", worldNamespace);
            worldCode = worldCode.Replace("{classname}", worldName);
            worldCode = worldCode.Replace("{components}", componentsCode);
            System.IO.File.WriteAllText(generatedFilePath, worldCode);
            return true;
        }

        protected static bool IsMonoProperty(FieldInfo field)
        {
            System.Type monoType = typeof(MonoBehaviour);
            MemberInfo[] memberInfos = monoType.GetMember(field.Name);
            if (memberInfos == null || memberInfos.Length <= 0) return false;
            PropertyInfo propertyInfo;
            FieldInfo fieldInfo;
            int count = memberInfos.Length;
            for(int i = 0; i < count; i++)
            {
                if (memberInfos[i].MemberType == MemberTypes.Property)
                {
                    propertyInfo = memberInfos[i] as PropertyInfo;
                    if (propertyInfo.PropertyType.Equals(field.FieldType))
                    {
                        return true;
                    }
                }
                else if (memberInfos[i].MemberType == MemberTypes.Field)
                {
                    fieldInfo = memberInfos[i] as FieldInfo;
                    if (fieldInfo.IsPrivate) continue;
                    if (fieldInfo.FieldType.Equals(field.FieldType))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        protected static string GetTypeName(System.Type type)
        {
            if (type.Equals(typeof(bool))) return "bool";
            if (type.Equals(typeof(short))) return "short";
            if (type.Equals(typeof(int))) return "int";
            if (type.Equals(typeof(long))) return "long";
            if (type.Equals(typeof(ushort))) return "ushort";
            if (type.Equals(typeof(uint))) return "uint";
            if (type.Equals(typeof(ulong))) return "ulong";
            if (type.Equals(typeof(float))) return "float";
            if (type.Equals(typeof(double))) return "double";
            if (type.Equals(typeof(string))) return "string";
            return type.Name;
        }

        protected static string GetTypeDefaultValue(System.Type type)
        {
            if (type.Equals(typeof(bool))) return "false";
            if (type.Equals(typeof(short))) return "0";
            if (type.Equals(typeof(int))) return "0";
            if (type.Equals(typeof(long))) return "0";
            if (type.Equals(typeof(ushort))) return "0";
            if (type.Equals(typeof(uint))) return "0";
            if (type.Equals(typeof(ulong))) return "0";
            if (type.Equals(typeof(float))) return "0f";
            if (type.Equals(typeof(double))) return "0";
            if (type.Equals(typeof(string))) return "string.Empty";
            return "null";
        }
    }
}
